import React, { useState, useRef, useEffect } from 'react';
import { Upload, Download, Move, RotateCw, Eye, EyeOff, Trash2, Plus, Settings } from 'lucide-react';

export default function ThumbnailCreator() {
  const [layers, setLayers] = useState([]);
  const [selectedLayer, setSelectedLayer] = useState(null);
  const [showExportModal, setShowExportModal] = useState(false);
  const [advancedControls, setAdvancedControls] = useState({});
  const [exportSettings, setExportSettings] = useState({
    format: 'png',
    quality: 90,
    size: '1920x1080'
  });
  const [isDragging, setIsDragging] = useState(false);
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
  const canvasRef = useRef(null);
  const fileInputRef = useRef(null);

  // Canvas dimensions
  const CANVAS_WIDTH = 1920;
  const CANVAS_HEIGHT = 1080;

  useEffect(() => {
    drawCanvas();
  }, [layers]);

  const handleFileUpload = (event) => {
    const files = Array.from(event.target.files);
    
    files.forEach((file) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          const newLayer = {
            id: Date.now() + Math.random(),
            name: file.name,
            type: 'image',
            image: img,
            x: 0,
            y: 0,
            width: img.width,
            height: img.height,
            opacity: 1,
            visible: true,
            rotation: 0,
            scale: 1
          };
          setLayers(prev => [newLayer, ...prev]);
          setSelectedLayer(newLayer.id);
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    });
    
    event.target.value = '';
  };

  const addTextLayer = () => {
    const newLayer = {
      id: Date.now() + Math.random(),
      name: 'Text Layer',
      type: 'text',
      x: 100,
      y: 100,
      width: 200,
      height: 50,
      opacity: 1,
      visible: true,
      rotation: 0,
      scale: 1,
      text: 'Sample Text',
      fontSize: 48,
      fontFamily: 'Arial',
      fontWeight: 'normal',
      fontStyle: 'normal',
      textDecoration: 'none',
      fontColor: '#000000',
      stroke1: { width: 0, color: '#ffffff' },
      stroke2: { width: 0, color: '#000000' },
      shadow: { enabled: false, x: 2, y: 2, blur: 4, color: '#000000' },
      glow: { enabled: false, blur: 10, color: '#ffffff', opacity: 0.8 }
    };
    setLayers(prev => [newLayer, ...prev]);
    setSelectedLayer(newLayer.id);
  };

  // Helper function to calculate text bounds
  const calculateTextBounds = (layer) => {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    ctx.font = `${layer.fontStyle} ${layer.fontWeight} ${layer.fontSize}px ${layer.fontFamily}`;
    const metrics = ctx.measureText(layer.text);
    
    // Calculate actual text width and height
    const textWidth = metrics.width;
    const textHeight = layer.fontSize; // Approximate height
    
    // Add stroke width to bounds
    const totalStrokeWidth = Math.max(layer.stroke1.width, layer.stroke2.width);
    const padding = totalStrokeWidth + 10; // Extra padding for easier selection
    
    return {
      width: textWidth + padding * 2,
      height: textHeight + padding * 2
    };
  };

  const drawCanvas = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    
    // Clear canvas with white background
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    
    // Draw layers in reverse order (last in array = bottom layer)
    [...layers].reverse()
      .filter(layer => layer.visible)
      .forEach(layer => {
        ctx.save();
        ctx.globalAlpha = layer.opacity;
        
        if (layer.type === 'image') {
          // Draw image layer
          const centerX = layer.x + (layer.width * layer.scale) / 2;
          const centerY = layer.y + (layer.height * layer.scale) / 2;
          
          ctx.translate(centerX, centerY);
          ctx.rotate((layer.rotation * Math.PI) / 180);
          ctx.scale(layer.scale, layer.scale);
          
          ctx.drawImage(
            layer.image,
            -layer.width / 2,
            -layer.height / 2,
            layer.width,
            layer.height
          );
        } else if (layer.type === 'text') {
          // Draw text layer
          const centerX = layer.x + (layer.width * layer.scale) / 2;
          const centerY = layer.y + (layer.height * layer.scale) / 2;
          
          ctx.translate(centerX, centerY);
          ctx.rotate((layer.rotation * Math.PI) / 180);
          ctx.scale(layer.scale, layer.scale);
          
          ctx.font = `${layer.fontStyle} ${layer.fontWeight} ${layer.fontSize}px ${layer.fontFamily}`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          
          // Draw glow effect first (behind everything) - render complete text with glow
          if (layer.glow.enabled) {
            ctx.save();
            ctx.shadowColor = layer.glow.color;
            ctx.shadowBlur = layer.glow.blur;
            ctx.globalAlpha = layer.glow.opacity;
            
            // Render the complete text with strokes for glow
            if (layer.stroke2.width > 0) {
              ctx.strokeStyle = layer.stroke2.color;
              ctx.lineWidth = layer.stroke2.width;
              ctx.lineJoin = 'round';
              ctx.lineCap = 'round';
              ctx.strokeText(layer.text, 0, 0);
            }
            
            if (layer.stroke1.width > 0) {
              ctx.strokeStyle = layer.stroke1.color;
              ctx.lineWidth = layer.stroke1.width;
              ctx.lineJoin = 'round';
              ctx.lineCap = 'round';
              ctx.strokeText(layer.text, 0, 0);
            }
            
            ctx.fillStyle = layer.fontColor;
            ctx.fillText(layer.text, 0, 0);
            
            ctx.restore();
          }
          
          // If drop shadow is enabled, render the complete text with shadow
          if (layer.shadow.enabled) {
            ctx.save();
            ctx.shadowColor = layer.shadow.color;
            ctx.shadowOffsetX = layer.shadow.x;
            ctx.shadowOffsetY = layer.shadow.y;
            ctx.shadowBlur = layer.shadow.blur;
            
            // Render the complete text with strokes for shadow
            if (layer.stroke2.width > 0) {
              ctx.strokeStyle = layer.stroke2.color;
              ctx.lineWidth = layer.stroke2.width;
              ctx.lineJoin = 'round';
              ctx.lineCap = 'round';
              ctx.strokeText(layer.text, 0, 0);
            }
            
            if (layer.stroke1.width > 0) {
              ctx.strokeStyle = layer.stroke1.color;
              ctx.lineWidth = layer.stroke1.width;
              ctx.lineJoin = 'round';
              ctx.lineCap = 'round';
              ctx.strokeText(layer.text, 0, 0);
            }
            
            ctx.fillStyle = layer.fontColor;
            ctx.fillText(layer.text, 0, 0);
            
            ctx.restore();
          }
          
          // Now draw the actual text without effects (on top)
          ctx.save();
          
          // Draw second stroke (outermost)
          if (layer.stroke2.width > 0) {
            ctx.strokeStyle = layer.stroke2.color;
            ctx.lineWidth = layer.stroke2.width;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.strokeText(layer.text, 0, 0);
          }
          
          // Draw first stroke (inner)
          if (layer.stroke1.width > 0) {
            ctx.strokeStyle = layer.stroke1.color;
            ctx.lineWidth = layer.stroke1.width;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.strokeText(layer.text, 0, 0);
          }
          
          // Draw main text (on top)
          ctx.fillStyle = layer.fontColor;
          ctx.fillText(layer.text, 0, 0);
          
          ctx.restore();
        }
        
        ctx.restore();
        
        // Draw selection outline for selected layer
        if (selectedLayer === layer.id) {
          ctx.strokeStyle = '#3b82f6';
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 5]);
          ctx.strokeRect(
            layer.x - 2,
            layer.y - 2,
            layer.width * layer.scale + 4,
            layer.height * layer.scale + 4
          );
          ctx.setLineDash([]);
        }
      });
  };

  const updateLayer = (id, updates) => {
    setLayers(prev => prev.map(layer => {
      if (layer.id === id) {
        const updatedLayer = { ...layer, ...updates };
        
        // Update text bounds if it's a text layer and relevant properties changed
        if (updatedLayer.type === 'text' && 
            (updates.text !== undefined || updates.fontSize !== undefined || 
             updates.fontFamily !== undefined || updates.fontWeight !== undefined || 
             updates.fontStyle !== undefined || updates.stroke1 !== undefined || 
             updates.stroke2 !== undefined)) {
          const bounds = calculateTextBounds(updatedLayer);
          updatedLayer.width = bounds.width;
          updatedLayer.height = bounds.height;
        }
        
        return updatedLayer;
      }
      return layer;
    }));
  };

  const deleteLayer = (id) => {
    setLayers(prev => prev.filter(layer => layer.id !== id));
    setSelectedLayer(null);
  };

  const moveLayer = (id, direction) => {
    setLayers(prev => {
      const index = prev.findIndex(layer => layer.id === id);
      if (index === -1) return prev;
      
      const newLayers = [...prev];
      if (direction === 'up' && index > 0) {
        [newLayers[index], newLayers[index - 1]] = [newLayers[index - 1], newLayers[index]];
      } else if (direction === 'down' && index < newLayers.length - 1) {
        [newLayers[index], newLayers[index + 1]] = [newLayers[index + 1], newLayers[index]];
      }
      return newLayers;
    });
  };

  const handleCanvasMouseDown = (e) => {
    if (!selectedLayer) return;
    
    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    const scaleX = CANVAS_WIDTH / rect.width;
    const scaleY = CANVAS_HEIGHT / rect.height;
    
    const mouseX = (e.clientX - rect.left) * scaleX;
    const mouseY = (e.clientY - rect.top) * scaleY;
    
    const layer = layers.find(l => l.id === selectedLayer);
    if (!layer) return;
    
    // Check if click is within layer bounds
    const layerBounds = {
      left: layer.x,
      top: layer.y,
      right: layer.x + layer.width * layer.scale,
      bottom: layer.y + layer.height * layer.scale
    };
    
    if (mouseX >= layerBounds.left && mouseX <= layerBounds.right &&
        mouseY >= layerBounds.top && mouseY <= layerBounds.bottom) {
      setIsDragging(true);
      setDragOffset({
        x: mouseX - layer.x,
        y: mouseY - layer.y
      });
    }
  };

  const handleCanvasMouseMove = (e) => {
    if (!isDragging || !selectedLayer) return;
    
    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    const scaleX = CANVAS_WIDTH / rect.width;
    const scaleY = CANVAS_HEIGHT / rect.height;
    
    const mouseX = (e.clientX - rect.left) * scaleX;
    const mouseY = (e.clientY - rect.top) * scaleY;
    
    updateLayer(selectedLayer, {
      x: mouseX - dragOffset.x,
      y: mouseY - dragOffset.y
    });
  };

  const handleCanvasMouseUp = () => {
    setIsDragging(false);
  };

  const exportImage = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    // Create export canvas with selected dimensions
    const exportCanvas = document.createElement('canvas');
    const exportCtx = exportCanvas.getContext('2d');
    
    const [width, height] = exportSettings.size.split('x').map(Number);
    exportCanvas.width = width;
    exportCanvas.height = height;
    
    // Scale factor for export
    const scaleX = width / CANVAS_WIDTH;
    const scaleY = height / CANVAS_HEIGHT;
    
    // Draw white background
    exportCtx.fillStyle = '#ffffff';
    exportCtx.fillRect(0, 0, width, height);
    
    // Draw layers scaled to export size
    [...layers].reverse()
      .filter(layer => layer.visible)
      .forEach(layer => {
        exportCtx.save();
        exportCtx.globalAlpha = layer.opacity;
        
        const centerX = (layer.x + (layer.width * layer.scale) / 2) * scaleX;
        const centerY = (layer.y + (layer.height * layer.scale) / 2) * scaleY;
        
        exportCtx.translate(centerX, centerY);
        exportCtx.rotate((layer.rotation * Math.PI) / 180);
        exportCtx.scale(layer.scale * scaleX, layer.scale * scaleY);
        
        exportCtx.drawImage(
          layer.image,
          -layer.width / 2,
          -layer.height / 2,
          layer.width,
          layer.height
        );
        
        exportCtx.restore();
      });
    
    try {
      const quality = exportSettings.format === 'jpeg' ? exportSettings.quality / 100 : 1;
      const mimeType = exportSettings.format === 'jpeg' ? 'image/jpeg' : 'image/png';
      const dataURL = exportCanvas.toDataURL(mimeType, quality);
      
      const newWindow = window.open();
      if (newWindow) {
        newWindow.document.write(`
          <html>
            <head><title>Thumbnail Export</title></head>
            <body style="margin:0; display:flex; justify-content:center; align-items:center; min-height:100vh; background:#f0f0f0;">
              <div style="text-align:center;">
                <h2>Right-click the image below and "Save Image As..."</h2>
                <img src="${dataURL}" alt="Thumbnail" style="max-width:100%; border:1px solid #ccc; box-shadow:0 4px 8px rgba(0,0,0,0.1);" />
                <p><strong>Dimensions:</strong> ${width} × ${height} pixels | <strong>Format:</strong> ${exportSettings.format.toUpperCase()}</p>
              </div>
            </body>
          </html>
        `);
        newWindow.document.close();
      }
    } catch (error) {
      console.error('Export failed:', error);
      alert('Export failed. Make sure you have images loaded on the canvas.');
    }
    
    setShowExportModal(false);
  };

  const LayerControls = ({ layer }) => {
    const showAdvanced = advancedControls[layer.id] || false;
    
    const toggleAdvanced = () => {
      setAdvancedControls(prev => ({
        ...prev,
        [layer.id]: !showAdvanced
      }));
    };
    
    return (
      <div className="space-y-3">
        <button
          onClick={toggleAdvanced}
          className="w-full px-3 py-1 text-xs text-gray-600 border border-gray-300 rounded hover:bg-gray-50"
        >
          {showAdvanced ? 'Hide' : 'Show'} Advanced Controls
        </button>
        
        {/* Common Controls */}
        <div className="grid grid-cols-2 gap-2">
          <div>
            <label className="block text-xs text-gray-600 mb-1">X Position</label>
            <input
              type="number"
              value={Math.round(layer.x)}
              onChange={(e) => updateLayer(layer.id, { x: parseInt(e.target.value) || 0 })}
              className="w-full px-2 py-1 border rounded text-sm"
              step="5"
            />
          </div>
          <div>
            <label className="block text-xs text-gray-600 mb-1">Y Position</label>
            <input
              type="number"
              value={Math.round(layer.y)}
              onChange={(e) => updateLayer(layer.id, { y: parseInt(e.target.value) || 0 })}
              className="w-full px-2 py-1 border rounded text-sm"
              step="5"
            />
          </div>
        </div>
        
        <div>
          <div className="flex justify-between items-center mb-1">
            <label className="text-xs text-gray-600">Scale: {layer.scale.toFixed(2)}</label>
            {showAdvanced && (
              <input
                type="number"
                value={layer.scale.toFixed(2)}
                onChange={(e) => updateLayer(layer.id, { scale: parseFloat(e.target.value) || 1 })}
                className="w-16 px-1 py-0.5 border rounded text-xs"
                step="0.01"
                min="0.1"
                max="5"
              />
            )}
          </div>
          <input
            type="range"
            min="0.1"
            max="3"
            step="0.01"
            value={layer.scale}
            onChange={(e) => updateLayer(layer.id, { scale: parseFloat(e.target.value) })}
            className="w-full"
          />
        </div>
        
        <div>
          <div className="flex justify-between items-center mb-1">
            <label className="text-xs text-gray-600">Opacity: {Math.round(layer.opacity * 100)}%</label>
            {showAdvanced && (
              <input
                type="number"
                value={Math.round(layer.opacity * 100)}
                onChange={(e) => updateLayer(layer.id, { opacity: (parseInt(e.target.value) || 0) / 100 })}
                className="w-12 px-1 py-0.5 border rounded text-xs"
                min="0"
                max="100"
              />
            )}
          </div>
          <input
            type="range"
            min="0"
            max="1"
            step="0.01"
            value={layer.opacity}
            onChange={(e) => updateLayer(layer.id, { opacity: parseFloat(e.target.value) })}
            className="w-full"
          />
        </div>
        
        <div>
          <div className="flex justify-between items-center mb-1">
            <label className="text-xs text-gray-600">Rotation: {layer.rotation}°</label>
            {showAdvanced && (
              <input
                type="number"
                value={layer.rotation}
                onChange={(e) => updateLayer(layer.id, { rotation: parseInt(e.target.value) || 0 })}
                className="w-16 px-1 py-0.5 border rounded text-xs"
                min="-180"
                max="180"
              />
            )}
          </div>
          <input
            type="range"
            min="-180"
            max="180"
            step="1"
            value={layer.rotation}
            onChange={(e) => updateLayer(layer.id, { rotation: parseInt(e.target.value) })}
            className="w-full"
          />
        </div>
        
        {/* Text-specific Controls */}
        {layer.type === 'text' && (
          <div className="border-t pt-3 space-y-3">
            <div>
              <label className="block text-xs text-gray-600 mb-1">Text</label>
              <textarea
                value={layer.text}
                onChange={(e) => updateLayer(layer.id, { text: e.target.value })}
                className="w-full px-2 py-1 border rounded text-sm resize-none"
                rows="2"
                onMouseDown={(e) => e.stopPropagation()}
                onFocus={(e) => e.stopPropagation()}
              />
            </div>
            
            <div className="grid grid-cols-2 gap-2">
              <div>
                <label className="block text-xs text-gray-600 mb-1">Font Size</label>
                <input
                  type="number"
                  value={layer.fontSize}
                  onChange={(e) => updateLayer(layer.id, { fontSize: parseInt(e.target.value) || 12 })}
                  className="w-full px-2 py-1 border rounded text-sm"
                  min="8"
                  max="200"
                  onMouseDown={(e) => e.stopPropagation()}
                />
              </div>
              <div>
                <label className="block text-xs text-gray-600 mb-1">Font Family</label>
                <select
                  value={layer.fontFamily}
                  onChange={(e) => updateLayer(layer.id, { fontFamily: e.target.value })}
                  className="w-full px-2 py-1 border rounded text-sm"
                  onMouseDown={(e) => e.stopPropagation()}
                >
                  <option value="Arial">Arial</option>
                  <option value="Helvetica">Helvetica</option>
                  <option value="Times New Roman">Times New Roman</option>
                  <option value="Georgia">Georgia</option>
                  <option value="Verdana">Verdana</option>
                  <option value="Courier New">Courier New</option>
                  <option value="Impact">Impact</option>
                  <option value="Comic Sans MS">Comic Sans MS</option>
                </select>
              </div>
            </div>
            
            <div>
              <label className="block text-xs text-gray-600 mb-1">Text Style</label>
              <div className="flex gap-2">
                <button
                  onClick={() => updateLayer(layer.id, { fontWeight: layer.fontWeight === 'bold' ? 'normal' : 'bold' })}
                  className={`px-2 py-1 text-sm font-bold border rounded ${layer.fontWeight === 'bold' ? 'bg-blue-500 text-white' : 'bg-white'}`}
                >
                  B
                </button>
                <button
                  onClick={() => updateLayer(layer.id, { fontStyle: layer.fontStyle === 'italic' ? 'normal' : 'italic' })}
                  className={`px-2 py-1 text-sm italic border rounded ${layer.fontStyle === 'italic' ? 'bg-blue-500 text-white' : 'bg-white'}`}
                >
                  I
                </button>
                <button
                  onClick={() => updateLayer(layer.id, { textDecoration: layer.textDecoration === 'underline' ? 'none' : 'underline' })}
                  className={`px-2 py-1 text-sm underline border rounded ${layer.textDecoration === 'underline' ? 'bg-blue-500 text-white' : 'bg-white'}`}
                >
                  U
                </button>
              </div>
            </div>
            
            <div>
              <label className="block text-xs text-gray-600 mb-1">Font Color</label>
              <input
                type="color"
                value={layer.fontColor}
                onChange={(e) => updateLayer(layer.id, { fontColor: e.target.value })}
                className="w-full h-8 border rounded"
                onMouseDown={(e) => e.stopPropagation()}
              />
            </div>
            
            <div>
              <label className="block text-xs text-gray-600 mb-1">Stroke 1 (Inner)</label>
              <div className="grid grid-cols-2 gap-2">
                <input
                  type="number"
                  value={layer.stroke1.width}
                  onChange={(e) => updateLayer(layer.id, { stroke1: { ...layer.stroke1, width: parseInt(e.target.value) || 0 } })}
                  className="w-full px-2 py-1 border rounded text-sm"
                  placeholder="Width"
                  min="0"
                  onMouseDown={(e) => e.stopPropagation()}
                />
                <input
                  type="color"
                  value={layer.stroke1.color}
                  onChange={(e) => updateLayer(layer.id, { stroke1: { ...layer.stroke1, color: e.target.value } })}
                  className="w-full h-8 border rounded"
                  onMouseDown={(e) => e.stopPropagation()}
                />
              </div>
            </div>
            
            <div>
              <label className="block text-xs text-gray-600 mb-1">Stroke 2 (Outer)</label>
              <div className="grid grid-cols-2 gap-2">
                <input
                  type="number"
                  value={layer.stroke2.width}
                  onChange={(e) => updateLayer(layer.id, { stroke2: { ...layer.stroke2, width: parseInt(e.target.value) || 0 } })}
                  className="w-full px-2 py-1 border rounded text-sm"
                  placeholder="Width"
                  min="0"
                  onMouseDown={(e) => e.stopPropagation()}
                />
                <input
                  type="color"
                  value={layer.stroke2.color}
                  onChange={(e) => updateLayer(layer.id, { stroke2: { ...layer.stroke2, color: e.target.value } })}
                  className="w-full h-8 border rounded"
                  onMouseDown={(e) => e.stopPropagation()}
                />
              </div>
            </div>
            
            <div>
              <label className="flex items-center space-x-2 text-xs text-gray-600 mb-1">
                <input
                  type="checkbox"
                  checked={layer.shadow.enabled}
                  onChange={(e) => updateLayer(layer.id, { shadow: { ...layer.shadow, enabled: e.target.checked } })}
                  onMouseDown={(e) => e.stopPropagation()}
                />
                <span>Drop Shadow</span>
              </label>
              {layer.shadow.enabled && (
                <div className="grid grid-cols-2 gap-2">
                  <div>
                    <label className="block text-xs text-gray-500 mb-1">X Offset</label>
                    <input
                      type="number"
                      value={layer.shadow.x}
                      onChange={(e) => updateLayer(layer.id, { shadow: { ...layer.shadow, x: parseInt(e.target.value) || 0 } })}
                      className="w-full px-2 py-1 border rounded text-sm"
                      onMouseDown={(e) => e.stopPropagation()}
                    />
                  </div>
                  <div>
                    <label className="block text-xs text-gray-500 mb-1">Y Offset</label>
                    <input
                      type="number"
                      value={layer.shadow.y}
                      onChange={(e) => updateLayer(layer.id, { shadow: { ...layer.shadow, y: parseInt(e.target.value) || 0 } })}
                      className="w-full px-2 py-1 border rounded text-sm"
                      onMouseDown={(e) => e.stopPropagation()}
                    />
                  </div>
                  <div>
                    <label className="block text-xs text-gray-500 mb-1">Blur</label>
                    <input
                      type="number"
                      value={layer.shadow.blur}
                      onChange={(e) => updateLayer(layer.id, { shadow: { ...layer.shadow, blur: parseInt(e.target.value) || 0 } })}
                      className="w-full px-2 py-1 border rounded text-sm"
                      onMouseDown={(e) => e.stopPropagation()}
                    />
                  </div>
                  <div>
                    <label className="block text-xs text-gray-500 mb-1">Color</label>
                    <input
                      type="color"
                      value={layer.shadow.color}
                      onChange={(e) => updateLayer(layer.id, { shadow: { ...layer.shadow, color: e.target.value } })}
                      className="w-full h-8 border rounded"
                      onMouseDown={(e) => e.stopPropagation()}
                    />
                  </div>
                </div>
              )}
            </div>
            
            <div>
              <label className="flex items-center space-x-2 text-xs text-gray-600 mb-1">
                <input
                  type="checkbox"
                  checked={layer.glow.enabled}
                  onChange={(e) => updateLayer(layer.id, { glow: { ...layer.glow, enabled: e.target.checked } })}
                  onMouseDown={(e) => e.stopPropagation()}
                />
                <span>Outer Glow</span>
              </label>
              {layer.glow.enabled && (
                <div className="grid grid-cols-3 gap-2">
                  <div>
                    <label className="block text-xs text-gray-500 mb-1">Blur</label>
                    <input
                      type="number"
                      value={layer.glow.blur}
                      onChange={(e) => updateLayer(layer.id, { glow: { ...layer.glow, blur: parseInt(e.target.value) || 0 } })}
                      className="w-full px-2 py-1 border rounded text-sm"
                      onMouseDown={(e) => e.stopPropagation()}
                    />
                  </div>
                  <div>
                    <label className="block text-xs text-gray-500 mb-1">Opacity</label>
                    <input
                      type="range"
                      min="0"
                      max="1"
                      step="0.1"
                      value={layer.glow.opacity}
                      onChange={(e) => updateLayer(layer.id, { glow: { ...layer.glow, opacity: parseFloat(e.target.value) } })}
                      className="w-full"
                      title={`${Math.round(layer.glow.opacity * 100)}%`}
                    />
                  </div>
                  <div>
                    <label className="block text-xs text-gray-500 mb-1">Color</label>
                    <input
                      type="color"
                      value={layer.glow.color}
                      onChange={(e) => updateLayer(layer.id, { glow: { ...layer.glow, color: e.target.value } })}
                      className="w-full h-8 border rounded"
                      onMouseDown={(e) => e.stopPropagation()}
                    />
                  </div>
                </div>
              )}
            </div>
          </div>
        )}
      </div>
    );
  };

  const ExportModal = () => (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white rounded-lg p-6 w-96">
        <h2 className="text-xl font-bold mb-4">Export Settings</h2>
        
        <div className="space-y-4">
          <div>
            <label className="block text-sm font-medium mb-2">Size</label>
            <select
              value={exportSettings.size}
              onChange={(e) => setExportSettings(prev => ({ ...prev, size: e.target.value }))}
              className="w-full p-2 border rounded"
            >
              <option value="1920x1080">1920 × 1080 (Full HD)</option>
              <option value="1280x720">1280 × 720 (YouTube Standard)</option>
            </select>
          </div>
          
          <div>
            <label className="block text-sm font-medium mb-2">Format</label>
            <select
              value={exportSettings.format}
              onChange={(e) => setExportSettings(prev => ({ ...prev, format: e.target.value }))}
              className="w-full p-2 border rounded"
            >
              <option value="png">PNG (Lossless)</option>
              <option value="jpeg">JPEG (Compressed)</option>
            </select>
          </div>
          
          {exportSettings.format === 'jpeg' && (
            <div>
              <label className="block text-sm font-medium mb-2">Quality: {exportSettings.quality}%</label>
              <input
                type="range"
                min="10"
                max="100"
                value={exportSettings.quality}
                onChange={(e) => setExportSettings(prev => ({ ...prev, quality: parseInt(e.target.value) }))}
                className="w-full"
              />
            </div>
          )}
        </div>
        
        <div className="flex gap-2 mt-6">
          <button
            onClick={() => setShowExportModal(false)}
            className="flex-1 px-4 py-2 border rounded hover:bg-gray-50"
          >
            Cancel
          </button>
          <button
            onClick={exportImage}
            className="flex-1 px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700"
          >
            Export
          </button>
        </div>
      </div>
    </div>
  );

  return (
    <div className="flex h-screen bg-gray-100">
      {/* Left Panel - Layers */}
      <div className="w-80 bg-white border-r p-4 overflow-y-auto">
        <div className="mb-4">
          <div className="grid grid-cols-2 gap-2">
            <button
              onClick={() => fileInputRef.current?.click()}
              className="flex items-center justify-center gap-2 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
            >
              <Plus size={16} />
              Add Images
            </button>
            <button
              onClick={addTextLayer}
              className="flex items-center justify-center gap-2 px-4 py-2 bg-purple-600 text-white rounded hover:bg-purple-700"
            >
              <Plus size={16} />
              Add Text
            </button>
          </div>
          <input
            ref={fileInputRef}
            type="file"
            multiple
            accept="image/*"
            onChange={handleFileUpload}
            className="hidden"
          />
        </div>
        
        <div className="mb-4">
          <h3 className="font-semibold mb-2">Layers ({layers.length})</h3>
          <div className="space-y-2">
            {layers.map((layer, index) => (
              <div
                key={layer.id}
                className={`p-2 border rounded cursor-pointer ${
                  selectedLayer === layer.id ? 'border-blue-500 bg-blue-50' : 'border-gray-200'
                }`}
                onClick={() => setSelectedLayer(selectedLayer === layer.id ? null : layer.id)}
              >
                <div className="flex items-center justify-between">
                  <span className="text-sm font-medium truncate">{layer.name}</span>
                  <div className="flex gap-1">
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        updateLayer(layer.id, { visible: !layer.visible });
                      }}
                      className="p-1 hover:bg-gray-200 rounded"
                    >
                      {layer.visible ? <Eye size={12} /> : <EyeOff size={12} />}
                    </button>
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        moveLayer(layer.id, 'up');
                      }}
                      className="p-1 hover:bg-gray-200 rounded"
                      disabled={index === 0}
                    >
                      ↑
                    </button>
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        moveLayer(layer.id, 'down');
                      }}
                      className="p-1 hover:bg-gray-200 rounded"
                      disabled={index === layers.length - 1}
                    >
                      ↓
                    </button>
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        deleteLayer(layer.id);
                      }}
                      className="p-1 hover:bg-red-200 rounded text-red-600"
                    >
                      <Trash2 size={12} />
                    </button>
                  </div>
                </div>
              </div>
            ))}
          </div>
        </div>
        
        {selectedLayer && (
          <div className="border-t pt-4">
            <h3 className="font-semibold mb-2">Layer Properties</h3>
            <LayerControls layer={layers.find(l => l.id === selectedLayer)} />
          </div>
        )}
      </div>
      
      {/* Main Canvas Area */}
      <div className="flex-1 flex flex-col">
        <div className="bg-white border-b p-4 flex justify-between items-center">
          <h1 className="text-xl font-bold">YouTube Thumbnail Creator</h1>
          <button
            onClick={() => setShowExportModal(true)}
            disabled={layers.filter(layer => layer.visible).length === 0}
            className="flex items-center gap-2 px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 disabled:bg-gray-400 disabled:cursor-not-allowed"
          >
            <Download size={16} />
            Export
          </button>
        </div>
        
        <div className="flex-1 flex items-center justify-center p-4 bg-gray-50">
          <div className="bg-white p-4 rounded-lg shadow-lg">
            <div className="mb-2 text-sm text-gray-600 text-center">
              1920 × 1080 (Full HD) - Click and drag selected layer
            </div>
            <canvas
              ref={canvasRef}
              width={CANVAS_WIDTH}
              height={CANVAS_HEIGHT}
              className="border border-gray-300 max-w-full max-h-full"
              style={{ 
                width: 'auto', 
                height: 'auto',
                maxWidth: '800px',
                maxHeight: '450px',
                cursor: isDragging ? 'grabbing' : selectedLayer ? 'grab' : 'default'
              }}
              onMouseDown={handleCanvasMouseDown}
              onMouseMove={handleCanvasMouseMove}
              onMouseUp={handleCanvasMouseUp}
              onMouseLeave={handleCanvasMouseUp}
            />
          </div>
        </div>
      </div>
      
      {showExportModal && <ExportModal />}
    </div>
  );
}
